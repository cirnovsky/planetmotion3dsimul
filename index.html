<!DOCTYPE html>
<head>
  <meta charset="UTF-8" />
  <title>Planetary Simulation</title>
  <link rel="stylesheet" src="/src/styles/main.css" />
</head>
<body>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/"
    }
  }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/dat.gui"></script>
  <script type="module">
    import * as THREE from "three"
    import { OrbitControls } from "three/addons/controls/OrbitControls.js"

    const G = 0.00029591220828559104 // Gravitational constant in astronomical units
    const AU = 1 // Astronomical unit in simulation unit
    const DAY = 1 // 1s = 1day
    const dt = 0.05 // Time step in days
    let maxTrailLength = 300

    const scene = new THREE.Scene()
    const loader = new THREE.TextureLoader()
    // TODO: Background texture
    loader.load("url/to/background", function(texture) {
      scene.background = texture
    })

    const camera = new THREE.PerspectiveCamera(
      60, // fov 
      window.innerWidth / window.innerHeight, // aspect 
      0.01, // near plane 
      1000, // far plane
    )
    camera.position.set(0, 2, 5)

    const renderer = new THREE.WebGLRenderer({ antialias: true })
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)

    const controls = new OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true
    controls.dampingFactor = 0.05
    controls.enablePan = false
    controls.minDistance = 1 
    controls.maxDistance = 50

    const light = new THREE.PointLight(0xffffff, 2)
    light.position.set(0, 0, 0)
    scene.add(light)

    const bodies = []

    let createBody = (name, mass, position, velocity, size, color) => {
      const geometry = new THREE.SphereGeometry(size, 32, 32)
      const material = new THREE.MeshStandardMaterial({ color })
      const mesh = new THREE.Mesh(geometry, material)
      mesh.position.x = position.x 
      mesh.position.y = position.y 
      mesh.position.z = position.z 
      
      scene.add(mesh)

      const trailGeometry = new THREE.BufferGeometry().setFromPoints([position.clone()])
      const trailMaterial = new THREE.LineBasicMaterial({ color })
      const trailLine = new THREE.Line(trailGeometry, trailMaterial)

      // scene.add(trailLine)

      bodies.push({
        name, mass,
        pos: position.clone(),
        vel: velocity.clone(),
        acc: new THREE.Vector3(),
        mesh,
        trailPositions: [position.clone()],
        trailGeometry,
        trailLine
      })
    }

    createBody("Sun", 1, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), 0.1, 0xffff00)
    createBody("Earth", 0.000003, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0), 0.03, 0x3399ff)

    // gui
    const settings = {
      timeScale: 1,
      trailLength: maxTrailLength
    }
    const gui = new dat.GUI()
    // TODO: gui.add timeScale and trailLength

    THREE.Vector3.prototype.square = function() {
      return new THREE.Vector3(this.x ** 2, this.y ** 2, this.z ** 2)
    }

    // update physics. for more document refer to src/js/calc.js
    function tick() {
      for (let i = 0; i < bodies.length; ++i) {
        let now = bodies[i]
        now.acc.set(0, 0, 0)

        for (let j = 0; j < bodies.length; ++j) {
          if (i == j)
            continue
          let other = bodies[j]
          let rVec = new THREE.Vector3().subVectors(other.pos, now.pos)
          let dist = rVec.length()
          let accMag = G * other.mass / dist ** 2
          let accVec = rVec.clone().normalize().multiplyScalar(accMag)

          now.acc.add(accVec)
        }
      }

      for (let body of bodies) {
        let vel = body.vel.clone()
        
        body.vel.add(body.acc.clone().multiplyScalar(dt * settings.timeScale))
        body.pos.add(new THREE.Vector3().subVectors(body.vel.square(), vel.square()).divide(body.acc.clone().multiplyScalar(2)))

        body.mesh.position.copy(body.pos)

        // body.trailPositions.push(body.pos.clone())
        // if (body.trailPositions.length > maxTrailLength)
        //   body.trailPositions.shift()
        // body.trailGeometry.setFromPoints(body.trailPositions)

        // TODO: collision detection
      }
    }

    function animate() {
      requestAnimationFrame(animate)
      for (let i = 0; i < 4; ++i)
        tick()
      // controls.update()
      renderer.render(scene, camera)
    }

    animate()

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    })
    /*
    // Constants
    const G = 0.00029591220828559104; // Gravitational constant in AU^3 / (M☉ * day^2)
    const AU = 2; // Astronomical unit in simulation units
    const DAY = 1; // 1s = 1 day
    const dt = 0.05; // Time step in days

    // Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 1000);
    camera.position.set(0, 2, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Light
    const light = new THREE.PointLight(0xffffff, 2);
    light.position.set(0, 0, 0);
    scene.add(light);

    // Bodies
    const bodies = [];

    function createBody({ name, mass, position, velocity, size, color }) {
      const geom = new THREE.SphereGeometry(size, 32, 32);
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(position);
      scene.add(mesh);
      bodies.push({ name, mass, pos: position.clone(), vel: velocity.clone(), acc: new THREE.Vector3(), mesh });
    }

    // Sun
    createBody({
      name: 'Sun',
      mass: 1.0,
      position: new THREE.Vector3(0, 0, 0),
      velocity: new THREE.Vector3(0, 0, 0),
      size: 0.1,
      color: 0xffff00
    });

    // Earth
    createBody({
      name: 'Earth',
      mass: 0.000003, // Earth mass relative to Sun
      position: new THREE.Vector3(AU, 0, 0),
      velocity: new THREE.Vector3(0, 0, 0.017202), // ~2π AU / 365 days
      size: 0.03,
      color: 0x3399ff
    });

    // Mars
    createBody({
      name: 'Mars',
      mass: 0.0000003,
      position: new THREE.Vector3(1.52 * AU, 0, 0),
      velocity: new THREE.Vector3(0, 0, 0.013),
      size: 0.025,
      color: 0xff5533
    });

    // Physics loop
    function updatePhysics() {
      for (let i = 0; i < bodies.length; i++) {
        let body = bodies[i];
        body.acc.set(0, 0, 0); // reset acceleration

        for (let j = 0; j < bodies.length; j++) {
          if (i === j) continue;
          let other = bodies[j];
          let rVec = new THREE.Vector3().subVectors(other.pos, body.pos);
          let distance = rVec.length();
          let forceMag = G * other.mass / (distance * distance + 1e-6);
          let force = rVec.normalize().multiplyScalar(forceMag);
          body.acc.add(force);
        }
      }

      // Euler integration
      for (let body of bodies) {
        body.vel.add(body.acc.clone().multiplyScalar(dt));
        body.pos.add(body.vel.clone().multiplyScalar(dt));
        body.mesh.position.copy(body.pos);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      for (let step = 0; step < 4; step++) updatePhysics(); // simulate 4 sub-steps/frame
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    */
  </script>
</body>
